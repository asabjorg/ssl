/* A TCP echo server with timeouts.
 *
 * Note that you will not need to use select and the timeout for a
 * tftp server. However, select is also useful if you want to receive
 * from multiple sockets at the same time. Read the documentation for
 * select on how to do this (Hint: Iterate with FD_ISSET()).
 */

#include <assert.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <glib.h>

#include "chat.h"


/* Secure socket layer headers */
#include <openssl/ssl.h>
#include <openssl/err.h>

/* Defines */
#define RETURN_ERR(err,s) if ((err)==-1) { perror(s); exit(1); }
#define RETURN_SSL(err) if ((err)==-1) { ERR_print_errors_fp(stderr); exit(1); }
#define ERROR_CHECK_NEG_OR_0(status, msg) if((status <= 0)) { perror(msg); exit(EXIT_FAILURE); }
#define ERROR_CHECK_NEG(status, msg) if((status < 0)) { perror(msg); exit(EXIT_FAILURE); }
#define ERROR_CHECK_NOT(status, msg) if(!status) { perror(msg); }
#define ERROR_CHECK_NOT_NULL(status, msg) if((status == NULL)) { perror(msg); }


GTree * clients;

/* This can be used to build instances of GTree that index on
   the address of a connection. */
int sockaddr_in_cmp(const void *addr1, const void *addr2)
{
        const struct sockaddr_in *_addr1 = addr1;
        const struct sockaddr_in *_addr2 = addr2;

        /* If either of the pointers is NULL or the addresses
           belong to different families, we abort. */
		g_assert((_addr1 != NULL) && (_addr2 != NULL) &&
		(_addr1->sin_family == _addr2->sin_family));

        if (_addr1->sin_addr.s_addr < _addr2->sin_addr.s_addr) {
                return -1;
        } else if (_addr1->sin_addr.s_addr > _addr2->sin_addr.s_addr) {
                return 1;
        } else if (_addr1->sin_port < _addr2->sin_port) {
                return -1;
        } else if (_addr1->sin_port > _addr2->sin_port) {
                return 1;
        }
        return 0;
}

gboolean listen_for_messages(gpointer key, gpointer value, gpointer fd_set_par){

	struct user * le_user = value;
	struct sockaddr_in address = le_user->client;
	SSL * ssl = le_user->ssl;
	int fd = le_user->fd;
	int status = 0;	

	if (FD_ISSET(fd, (fd_set *)fd_set_par)){
		char msg[1024];
		status = SSL_read(ssl, msg, sizeof(msg) - 1);
		ERROR_CHECK_NEG_OR_0(status, "ERROR: Error reading in listen_for_messages\n");
		msg[status] = '\0';
		printf("User:%d says: %s\n", ntohs(address.sin_port), msg);
	}

	return FALSE;	
}


int main(int argc, char **argv)
{
	/* Checks if parameters are available and valid */
	server_startup_check(argc, argv);

	int status = 0;
	int sock;
	int listen_socket;
	struct sockaddr_in server, client;
    char buffer[4096];
	SSL * server_ssld;
	SSL_CTX * ssl_ctx;
	
	/* Initilize a client tree */
	clients = g_tree_new(sockaddr_in_cmp);

	/* Load encryption and hasing algortihms, and error strings */
	SSL_library_init();
	SSL_load_error_strings();

	/* Creating a SSL_CTX structure*/
	ssl_ctx = SSL_CTX_new(TLSv1_method());
	if(!ssl_ctx){
		printf("ERROR: Error creating context.\n");
		exit(EXIT_FAILURE);
	}

	/* Loading server certificate */
	status = SSL_CTX_use_certificate_file(ssl_ctx, "server.crt", SSL_FILETYPE_PEM);
	ERROR_CHECK_NEG_OR_0(status, "ERROR: Error loding server certificate.\n");
	
	/* Loading server privte key*/
	status = SSL_CTX_use_PrivateKey_file(ssl_ctx, "server.key", SSL_FILETYPE_PEM);
	ERROR_CHECK_NEG_OR_0(status, "ERROR: Error loding server private key.\n");
	
	/* Making sure certificate and private key match*/
	status = SSL_CTX_check_private_key(ssl_ctx);
	ERROR_CHECK_NEG_OR_0(status, "ERROR: Error matching private key.\n");

    /* Create and bind a TCP socket */
	listen_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	ERROR_CHECK_NEG(status, "ERROR: Error creating listen socket.\n");

	int fdincrementer = listen_socket;

	memset(&server, '\0', sizeof(server));
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = htonl(INADDR_ANY);
	server.sin_port = htons(atoi(argv[1]));
    
	/* Binding socket to port */    
	status = bind(listen_socket, (struct sockaddr *) &server, (socklen_t) sizeof(server));
	ERROR_CHECK_NEG(status, "ERROR: Could not bind to port.\n");

	 /* Listen to port */
	status = listen(listen_socket, MAX_USERS);
	ERROR_CHECK_NEG(status, "ERROR: Error while listening to listen_socket.\n");
	
	int FDS[1024];
	int c = 0;
	for(int i = 0; i < 1024; i++) FDS[i] = -1;

	while(TRUE){
        struct timeval tv;
		fd_set rfds;
		FD_ZERO(&rfds);
        int retval;
	
		//FD_ZERO(&rfds);
		int	fdincrementer = listen_socket;
		FD_SET(listen_socket, &rfds);		
		int anotherretval = 0;
		tv.tv_sec = 3;
		tv.tv_usec = 30;
		for(int i = 0; i < 1024; i++){
			if(FDS[i] > 0 ){
				FD_SET(FDS[i], &rfds);
				anotherretval += select(FDS[i] +1, &rfds, NULL, NULL, &tv);
				printf("another ret val %d\n", anotherretval);
				printf("connfd is  %d\n", FDS[i]);
			}
		}	

	
		anotherretval += select(listen_socket +  1, &rfds, NULL, NULL, &tv);
		ERROR_CHECK_NEG(retval, "ERROR: Error in select()\n");	
	
		/* If we we're able to "select something", it means we have a client */	
		if(anotherretval > 0){
			if(FD_ISSET(listen_socket, &rfds)){

			socklen_t len = (socklen_t) sizeof(client);
			
			/* Accept the connection*/
		 	int connfd = accept(listen_socket, (struct sockaddr *) &client, &len);
			printf("Connection from ip %lx port %d\n", client.sin_addr, ntohs(client.sin_port));
			log("connected", &client);
			
			/* Make an ssl structure for it*/
			SSL * client_ssl = SSL_new(ssl_ctx);
			if(!client_ssl){
                printf("ERROR: SSL new\n");
				exit(EXIT_FAILURE);
            }	
			
			SSL_set_fd(client_ssl, connfd);
			FD_SET(connfd, &rfds);
			FDS[c] = connfd;
			c++;
			
			status = SSL_accept(client_ssl);
			ERROR_CHECK_NEG(status, "SSL_accept error (try ERR_print_errors_fp\n");
	
			/* Constructing a key for the GTree */	
			long int client_key = construct_client_key(&client);
			ERROR_CHECK_NEG_OR_0(client_key, "ERROR: Error creating client key.\n");
		 
			/* Welcoming the client, the cliend verifies this msg */	
			status = SSL_write(client_ssl, "Welcome.\n", sizeof("Welcome.\n"));
			ERROR_CHECK_NEG_OR_0(status, "ERROR: Error sending welcome to client.\n");
			
			/* Receiving a hello from the client, just becausewhynot*/
			status = SSL_read(client_ssl, buffer, sizeof(buffer));
			buffer[status] = '\0';
			printf("INFO: client says %s\n", buffer);		

			/* Constructing a user object to store in the gtree*/			
			struct user le_user;
			memset(&le_user, '\0', sizeof(le_user)); 
			le_user.fd = connfd;
			le_user.ssl = client_ssl;
			le_user.client = client;		

			/* Inserting the user */
				g_tree_insert(clients, (void *) &client_key, (void *) &le_user);
			}
			/* Then we check all users for messages to read..............exept 
			 * it only works once ??*/
			//while(1){			
				g_tree_foreach(clients, listen_for_messages, &rfds);	
			//}

		}else{
		 	fprintf(stdout, "No message in five seconds.\n");
            fflush(stdout);
		}

	}
}
