/* A TCP echo server with timeouts.
 *
 * Note that you will not need to use select and the timeout for a
 * tftp server. However, select is also useful if you want to receive
 * from multiple sockets at the same time. Read the documentation for
 * select on how to do this (Hint: Iterate with FD_ISSET()).
 */

#include <assert.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <glib.h>

#include "chat.h"


/* Secure socket layer headers */
#include <openssl/ssl.h>
#include <openssl/err.h>

/* Defines */
#define RETURN_ERR(err,s) if ((err)==-1) { perror(s); exit(1); }
#define RETURN_SSL(err) if ((err)==-1) { ERR_print_errors_fp(stderr); exit(1); }
#define ERROR_CHECK_NEG_OR_0(status, msg) if((status <= 0)) { perror(msg); exit(EXIT_FAILURE); }
#define ERROR_CHECK_NEG(status, msg) if((status < 0)) { perror(msg); exit(EXIT_FAILURE); }
#define ERROR_CHECK_NOT(status, msg) if(!status) { perror(msg); }
#define ERROR_CHECK_NOT_NULL(status, msg) if((status == NULL)) { perror(msg); }


/* This can be used to build instances of GTree that index on
   the address of a connection. */
int sockaddr_in_cmp(const void *addr1, const void *addr2)
{
        const struct sockaddr_in *_addr1 = addr1;
        const struct sockaddr_in *_addr2 = addr2;

        /* If either of the pointers is NULL or the addresses
           belong to different families, we abort. */
		g_assert((_addr1 != NULL) && (_addr2 != NULL) &&
		(_addr1->sin_family == _addr2->sin_family));


        //g_assert((_addr1 == NULL) || (_addr2 == NULL) ||
          //       (_addr1->sin_family != _addr2->sin_family));

        if (_addr1->sin_addr.s_addr < _addr2->sin_addr.s_addr) {
                return -1;
        } else if (_addr1->sin_addr.s_addr > _addr2->sin_addr.s_addr) {
                return 1;
        } else if (_addr1->sin_port < _addr2->sin_port) {
                return -1;
        } else if (_addr1->sin_port > _addr2->sin_port) {
                return 1;
        }
        return 0;
}



int main(int argc, char **argv)
{
	/* Checks if parameters are available and valid */
	server_startup_check(argc, argv);

	int status = 0;
	int sock;
	int listen_socket;
	struct sockaddr_in server, client;
    char buffer[4096];
	SSL * server_ssld;
	SSL_CTX * ssl_ctx;
	GTree * clients;

	/* Initilize a client tree */
	clients = g_tree_new(sockaddr_in_cmp);


	/* Load encryption and hasing algortihms, and error strings */
	SSL_library_init();
	SSL_load_error_strings();

	/* Creating a SSL_CTX structure*/
	ssl_ctx = SSL_CTX_new(TLSv1_method());
	if(!ssl_ctx){
		printf("ERROR: Error creating context.\n");
		exit(EXIT_FAILURE);
	}

	/* Loading server certificate */
	status = SSL_CTX_use_certificate_file(ssl_ctx, "server.crt", SSL_FILETYPE_PEM);
	ERROR_CHECK_NEG_OR_0(status, "ERROR: Error loding server certificate.\n");
	
	/* Loading server privte key*/
	status = SSL_CTX_use_PrivateKey_file(ssl_ctx, "server.key", SSL_FILETYPE_PEM);
	ERROR_CHECK_NEG_OR_0(status, "ERROR: Error loding server private key.\n");
	
	/* Making sure certificate and private key match*/
	status = SSL_CTX_check_private_key(ssl_ctx);
	ERROR_CHECK_NEG_OR_0(status, "ERROR: Error matching private key.\n");

    /* Create and bind a TCP socket */
	listen_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	ERROR_CHECK_NEG(status, "ERROR: Error creating listen socket.\n");

	int fdincrementer = listen_socket;

	memset(&server, '\0', sizeof(server));
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = htonl(INADDR_ANY);
	server.sin_port = htons(atoi(argv[1]));
    
	/* Binding socket to port */    
	status = bind(listen_socket, (struct sockaddr *) &server, (socklen_t) sizeof(server));
	ERROR_CHECK_NEG(status, "ERROR: Could not bind to port.\n");

	 /* Listen to port */
	status = listen(listen_socket, MAX_USERS);

	while(TRUE){
        fd_set rfds;
        struct timeval tv;
        int retval;
	
		FD_ZERO(&rfds);
		FD_SET(listen_socket, &rfds);		
		int	fdincrementer = listen_socket;
		
		tv.tv_sec = 5;
		tv.tv_usec = 0;
		retval = select(fdincrementer + 1, &rfds, NULL, NULL, &tv);
		ERROR_CHECK_NEG(retval, "ERROR: Error in select()\n");	
		if(retval > 0){
			assert(FD_ISSET(listen_socket, &rfds));

			socklen_t len = (socklen_t) sizeof(client);
	
		 	int connfd = accept(listen_socket, (struct sockaddr *) &client, &len);
			printf("Connection from ip %lx port %d\n", inet_ntoa(client.sin_addr), ntohs(client.sin_port));

			SSL * client_ssl = SSL_new(ssl_ctx);
			if(!client_ssl){
                printf("ERROR: SSL new\n");
				exit(EXIT_FAILURE);
            }	
			
			SSL_set_fd(client_ssl, connfd);
		
			
			status = SSL_accept(client_ssl);
			ERROR_CHECK_NEG(status, "SSL_accept error (try ERR_print_errors_fp\n");
			
			printf("HERE 0  \n");
			
			long int client_key = construct_client_key(&client);
			ERROR_CHECK_NEG_OR_0(client_key, "ERROR: Error creating client key.\n");
	
			printf("HERE 1  \n");
		 	
			status = SSL_write(client_ssl, "Welcome.\n", sizeof("Welcome.\n"));
			ERROR_CHECK_NEG_OR_0(status, "ERROR: Error sending welcome to client.\n");
		
			printf("HERE22  \n");
			
			g_tree_insert(clients, client_key, (void *) &client);
			log("connected", &client);
			
			printf("HERE33  \n");
			
		}
		else{
		 	fprintf(stdout, "No message in five seconds.\n");
            fflush(stdout);
		}

	}
}






/*	
	size_t len;
	len = sizeof(client);
	
	/* Socket for a TCP/I 	connection created  */
/*	sock = accept(listen_socket, (struct sockaddr*)&client, &len);
	if(sock < 0){
		printf("ERROR: Error accepting ...\n");
		exit(EXIT_FAILURE);
	}

//	close(listen_socket); // the sample server does this ...............should we ??
	printf("Connection from: %lx, port %d\n", client.sin_addr.s_addr, ntohs(client.sin_port));

	/* TCP connection is ready, creating SSL structure*/	
/*	server_ssld = SSL_new(ssl_ctx);
	if(server_ssld == NULL){
		printf("ERROR: Error creating ssl struct.\n");
		exit(EXIT_FAILURE);
	}

	/* Assigning the socket to the SSL structure  */
/*	SSL_set_fd(server_ssld, sock);
	
	/* HANSHAKE */
/*	SSL_accept(server_ssld);

	printf("SSL connection using %s\n", SSL_get_cipher (server_ssld));
	log("connected\n", &client);

	long int client_key = construct_client_key(&client);

	/* Received data from client */
/*	status = SSL_read(server_ssld, buffer, sizeof(buffer)-1); 
	buffer[status] = '\0';
	printf("INFO: Client says: %s\n", buffer);

	/* Letting client know the connection has been established */
/*	status = SSL_write(server_ssld, "Welcome.", sizeof("Welcome."));
	 
	/* EVERYTHING BELOW IS WHAT MARCEL LEFT IN HERE */

/*	while(1){
		fd_set rfds;
        struct timeval tv;
        int retval;

       	/* Check whether there is data on the socket fd. */
/*		FD_ZERO(&rfds);
        FD_SET(sock, &rfds);

        /* Wait for five seconds. */
  /*      tv.tv_sec = 5;
        tv.tv_usec = 0;
        retval = select(sock + 1, &rfds, NULL, NULL, &tv);

        if (retval == -1) {
        	perror("select()");
        } else if (retval > 0) {
    /    	/* Data is available, receive it. */
     /*       assert(FD_ISSET(sock, &rfds));

            /* Copy to len, since recvfrom may change it. */
       /*     socklen_t len = (socklen_t) sizeof(client);

            /* For TCP connectios, we first have to accept. */
         /*   int connfd;
            connfd = accept(sock, (struct sockaddr *) &client,
                                        &len);
                        
           /* Receive one byte less than declared,
              because it will be zero-termianted
              below. */
           // ssize_t n = read(connfd, buffer, sizeof(buffer) - 1);
           
		/*	ssize_t n = SSL_read(server_ssld, buffer, sizeof(buffer)-1);
            buffer[n] = '\0';
			SSL_write(server_ssld, "Message received.\n",  sizeof("Message received.\n"));

             /* We should close the connection. */
          /*   shutdown(connfd, SHUT_RDWR);
             close(connfd);

             /* Zero terminate the message, otherwise
 	         printf may access memory outside of the
             string. */
            /* Print the message to stdout and flush. */
            /*  fprintf(stdout, "Port%d:  %s", ntohs(client.sin_port), buffer);
              fflush(stdout);
        } 
		else {
			fprintf(stdout, "No message in five seconds.\n");
            fflush(stdout);
        }
	}
}*/
